/**
 * K6 Load Test Template - Product Page
 *
 * Generated by Promo Load Analyzer
 * Target: {{ url }}
 * Mode: {{ mode }}
 * Environment: {{ environment }}
 */

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Counter, Trend } from 'k6/metrics';

// Custom metrics
const cartSuccess = new Counter('add_to_cart_success');
const cartFailed = new Counter('add_to_cart_failed');
const pageLoadTime = new Trend('page_load_time');

export const options = {
    // Load test stages: ramp-up, sustain, ramp-down
    stages: [
        {% for stage in stages -%}
        { duration: '{{ stage.duration }}', target: {{ stage.target }} },
        {% endfor -%}
    ],

    // Safety thresholds - abort test if exceeded
    thresholds: {
        {% if thresholds.http_req_failed -%}
        'http_req_failed': [
            {% for rule in thresholds.http_req_failed -%}
            {
                threshold: '{{ rule.threshold }}',
                abortOnFail: {{ rule.abort_on_fail|lower }},
                {% if rule.delay_abort_eval -%}
                delayAbortEval: '{{ rule.delay_abort_eval }}'
                {% endif -%}
            },
            {% endfor -%}
        ],
        {% endif -%}
        {% if thresholds.http_req_duration -%}
        'http_req_duration': [
            {% for rule in thresholds.http_req_duration -%}
            {
                threshold: '{{ rule.threshold }}',
                abortOnFail: {{ rule.abort_on_fail|lower }},
                {% if rule.delay_abort_eval -%}
                delayAbortEval: '{{ rule.delay_abort_eval }}'
                {% endif -%}
            },
            {% endfor -%}
        ],
        {% endif -%}
        {% if thresholds.checks -%}
        'checks': [
            {% for rule in thresholds.checks -%}
            {
                threshold: '{{ rule.threshold }}',
                abortOnFail: {{ rule.abort_on_fail|lower }},
                {% if rule.delay_abort_eval -%}
                delayAbortEval: '{{ rule.delay_abort_eval }}'
                {% endif -%}
            },
            {% endfor -%}
        ],
        {% endif -%}
    },

    // Test metadata
    tags: {
        test_type: 'product_page',
        environment: '{{ environment }}',
        mode: '{{ mode }}',
    },
};

/**
 * Main test scenario
 * Executed by each VU for each iteration
 */
export default function() {
    const baseUrl = '{{ url }}';

    // 1. Load product page
    const startTime = Date.now();
    const pageResponse = http.get(baseUrl, {
        tags: { name: 'product_page_load' },
    });
    const pageLoadDuration = Date.now() - startTime;
    pageLoadTime.add(pageLoadDuration);

    // Check page load success
    const pageOk = check(pageResponse, {
        'page loads successfully': (r) => r.status === 200,
        'page loads fast': (r) => r.timings.duration < 3000,
        'no server error': (r) => r.status < 500,
        'page contains product': (r) => r.body.includes('product') || r.body.includes('add-to-cart'),
    });

    if (!pageOk) {
        console.warn(`âš ï¸ Page check failed - VU ${__VU} iteration ${__ITER}`);
    }

    // Simulate user reading product details
    sleep(1 + Math.random() * 2);

    {% if mode == 'full' and id_product -%}
    // 2. Add product to cart (FULL mode only)
    const cartUrl = baseUrl.split('/').slice(0, 3).join('/') + '/module/ps_shoppingcart/ajax';

    let cartPayload = 'action=add-to-cart&id_product={{ id_product }}';
    {% if id_product_attribute -%}
    cartPayload += '&id_product_attribute={{ id_product_attribute }}';
    {% endif -%}
    cartPayload += '&qty=1';

    const cartResponse = http.post(cartUrl, cartPayload, {
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'X-Requested-With': 'XMLHttpRequest',
        },
        tags: { name: 'add_to_cart' },
    });

    const cartOk = check(cartResponse, {
        'cart add returns 200': (r) => r.status === 200,
        'cart response valid': (r) => {
            try {
                const body = JSON.parse(r.body);
                return body.success !== undefined || body.cart !== undefined;
            } catch (e) {
                return false;
            }
        },
    });

    if (cartOk) {
        cartSuccess.add(1);
    } else {
        cartFailed.add(1);
        console.warn(`âš ï¸ Add to cart failed - VU ${__VU} iteration ${__ITER}`);
    }

    // Simulate user viewing cart
    sleep(1 + Math.random());
    {% endif -%}

    // Think time before next iteration
    sleep(1 + Math.random());
}

/**
 * Setup function - runs once before test starts
 */
export function setup() {
    console.log('ğŸš€ Starting load test for product page: {{ url }}');
    console.log('ğŸ“Š Configuration:');
    console.log('   - Environment: {{ environment }}');
    console.log('   - Mode: {{ mode }}');
    console.log('   - Stages: {{ stages|length }} stages');
    {% if id_product -%}
    console.log('   - Product ID: {{ id_product }}');
    {% endif -%}
    {% if id_product_attribute -%}
    console.log('   - Attribute ID: {{ id_product_attribute }}');
    {% endif -%}
    console.log('');
    console.log('ğŸ›¡ï¸ Safety thresholds active - test will abort if exceeded');
    console.log('');

    // Warm-up request to verify target is reachable
    const warmupResponse = http.get('{{ url }}');
    if (warmupResponse.status !== 200) {
        console.error(`âŒ Warm-up request failed: ${warmupResponse.status}`);
        console.error('   Target may be unreachable. Aborting test.');
        return null;  // Abort test
    }

    console.log('âœ… Warm-up successful - target is reachable');
    return { startTime: new Date().toISOString() };
}

/**
 * Teardown function - runs once after test completes
 */
export function teardown(data) {
    if (data && data.startTime) {
        console.log('');
        console.log('ğŸ Load test completed');
        console.log(`   Started: ${data.startTime}`);
        console.log(`   Ended: ${new Date().toISOString()}`);
    }
    console.log('');
    console.log('ğŸ“Š Check k6 output above for detailed metrics and threshold status');
}
